<center><h1>C语言中函数调用的底层实现</h1></center>

前面讲运算符的时候，有一个函数调用运算符我们没有讲，因为我们要在函数中讲。

## 一、函数概述

函数是一种封装代码的方法，可以避免程序中的代码重复，提高代码可重用性和代码的简洁性、易读性。

函数中参数的传递有两种方式，分别是：值传递和指针传递。对于按值传递的参数，函数外部的参数和函数内部使用的参数，即实参和形参是两个不同的数据对象，即形参和实参保存在不同的内存区域中，因为按值传递时，形参是对实参数据对象的一个复制，函数内部对形参的改变并不会对实参产生影响。对于按指针传递的参数，函数内部使用的数据对象和函数外部的实参的数据对象是同一个数据对象，因此函数内部对于数据对象做出的修改会反映在一个（块）内存中，这块内存也是实参的内存空间，因此，实参也会受到影响。

上面的说教不免过于学究，看个例子：

![image-20220103154515858](https://raw.githubusercontent.com/zrmin/C-Programming-Language/master/images/202201031545164.png)

在foo()函数中有4个参数，前两个参数是值传递，函数内和函数外使用的是两个不同内存区域中的数据对象（即使它们的值相同），后两个参数是指针传递，第一个是a pointer to a struct，第二个是a pointer to a function，对于函数指针，可以省略`*`符号，也就是说foo()函数可以写成：

```c
int foo(int x, int y, Point* p, int(*handler)(int)) {
	return (*handler)(x + y + p->x + p->y);
}
```

函数指针的解释：`handler`的意识是a pointer to a function，`*handler`的意思是`a function`，这里的`*`是解引用运算符，`(*handler)(x + y + p->x + p->y)`的意思是a call to that function。



## 二、System V AMD64 ABI调用约定

不同平台的编译器在处理函数调用时，遵循的函数调用约定不同，例如在Windows平台上，函数被调用时编译器按照Microsoft x64或者Vector调用约定来对栈内存和寄存器等进行管理，在Unix和类Unix平台上，例如我们经常使用的gcc编译器，就是按照System V AMD64 ABI调用约定来对函数调用时涉及到的栈内存和寄存器等进行分配的。

由于我经常在Linux平台上做开发，所以我主要讲一下SystemV的调用约定。

![pictures](https://raw.githubusercontent.com/zrmin/C-Programming-Language/master/images/202201032036472.jpg)

1. <b>参数传递</b>

函数调用时，对于整型和指针型的实参，在调用时，按函数定义中的参数顺序从左到右依次使用`rdi`、`rsi`、`rdx`、`rcx`、`r8`、`r9`这6个寄存器来保存实参，<font color=red>从上图中的第36~41行可以看出来</font>，即分别是把：

* 第一个参数1保存在rdi寄存器中
* 第二个参数2保存在rsi寄存器中
* 第三个参数3保存在rdx寄存中
* 第四个参数4保存在rcx寄存器中
* 第五个参数5保存在r8寄存器中
* 第六个参数6保存在r9寄存器中

那如果函数接收的参数超过6个了，那么规定的这6个寄存器用完了怎么办呢？答：多出来的参数按照从右往左的顺序压入栈中，通过栈内存来保存。<font color=red>从上图中的第42~43行可以看出来</font>，即分别是把：

* 按照从右往左的顺序，我们应该先把8压入栈中，再把7压入栈中，事实上我们也是这么做的，如下：
* 第42行，将7压入栈顶指针所指的栈内存中，即`[rsp]`处
* 第43行，将8压入`[rsp + 8]`处
* 我们知道，在计算机中，栈是从高地址往低地址增长的，因此，第42行和第43行的操作等价于先将8压入栈内存，再将7压入栈内存

<font color=green>也许有人会有问题，问什么x和y的值不直接存储在寄存器rdi和rsi中，而是要先存储在栈内存中，然后再间接地赋给寄存器呢？这是因为x和y是函数内部的局部变量，所以它们最开始会被存储到栈内存中。</font>

整型和指针型的参数传递我们已经搞明白了，那么浮点型呢？毕竟，浮点数是我们写程序时常用的。

对于浮点参数，在SystemV调用约定中，编译器将使用xmm0到xmm7这8个寄存器来进行存储，对于更宽的值，也可能会使用ymm和zmm寄存器来代替xmm寄存器。至于xmm、ymm、zmm都是x86 ISA中名为AVX(Advanced Vector Extensions)的扩展指令集使用的。这些指令集专门用于浮点数计算以及SMID相关的处理。

举个例子如下：

![](https://raw.githubusercontent.com/zrmin/C-Programming-Language/master/images/202201032140462.jpg)

上图的处理流程其实和整型参数传递是大同小异的：

* 第47~50行，先将double 1赋给xmm0，将xmm0中的值，即double 1存储在栈内存中，因为double 1是函数中的局部变量。double 2也是这样处理
* 第51~55行，就是浮点参数传递的处理流程。按照函数定义时的从左到右的顺序分别将double 1赋给xmm0，double 2赋给xmm1，double 3赋给xmm2，double 4赋给xmm3，double 5赋给xmm4，至此，浮点传参时参数的保存就完成了
* 第56~58行，就是我们上面讲过的整型参数传递的处理：分别按从左到右的顺序将参数依次保存在寄存器rdi、rsi和rdx中。



2.  <b>返回值传递</b>

当调用的函数有返回值时，SystemV调用约定规定：

* 当返回值为整型且不超过64位时，通过rax寄存器来进行返回值的传递。<font color = red>如上图中第28行和第64行</font>
* 当返回值为整型且超过64位但不超过128位时，编译器通过使用寄存器rax和rdx来分别保存返回值的低64位和高64位
* 当返回值为浮点型时，编译器会使用xmm0和xmm1来进行存储。而当返回值过大时，会使用ymm和zmm。<font color=red>如上图中第6行</font>



3. <b>寄存器的caller-saved 和 callee-saved</b>

SystemV调用约定中规定，如果一个被调函数需要使用到`rbx`、`rbp`、`rsp`的话，那么在该被调函数真正地处理数据（如参数传递处理）之前（被调用前，可以结合下面的Red Zone来理解，在做calle-saved时，该函数并没有被调用），要在该被调函数中将rbx、rbp和rsp进行保存，并在函数返回之前，将它们恢复。这就是`callee-saved`，<font color=red>如上图中第4~5行、第10~11行、第43~44行</font>：

```assembly
push rbp ;保存当前的rbp中的值到栈内存中，以便在函数执行完毕后恢复rbp的值
mov rbp, rsp ;将当前rsp的值保存在rbp中，因为在处理被调用的函数时，需要分配栈空间
;因此，需要扩展（分配）一定的栈空间来保存函数中用到的数据，所以rsp在后面会被减去一个值来实现栈空间的分配
```

还如上图中第7行、第29~30行、第65~66行，以第65~66行为例：

```assembly
add rsp, 32 ;恢复rsp的值到该函数被调用前的值
pop rbp ;恢复rbp的值为函数调用前的rbp的值，因为函数调用前的rbp的值已经通过push rbp保存在栈内存中了
```

而对于rbx、rbp、rsp之外的其他寄存器，则由调用函数根据需要自行保存和恢复必要的寄存器的值。这就是`caller-saved`。



4. <b>其他约定</b>

SystemV还有一些重要的其他约定：

* 栈顶地址（以字节为单位）要16字节对齐，也就是说栈顶的地址值要是16的倍数
* 不同于用户函数的调用过程，系统调用函数（System Call）需要使用寄存器rdi、rsi、rdx、r10、r8、r9来传递参数
* 在栈顶往低地址方向留出128字节的空间，作为`Red Zone`

Red Zone是在栈顶增长方向专门为叶子函数留出的128字节空间，<font color = blue>注意：栈顶往上的地方有Red Zone，并不是栈顶往下包含了Red Zone。</font>所谓`叶子函数`就是说该函数不再调用其他的函数，如本节例子中，main()函数调用foo()函数，foo()函数又调用bar()函数，但是bar()函数并没有调用其他函数，因此，bar()函数就是我们所说的`叶子函数`。Red Zone空间的留出是为了减少叶子函数中的修改rsp，即扩充栈内存空间的时间，提升函数的执行速度。

举个例子如下：我们在Red Zone的128字节中存储了33个整数，即132个字节，因此需要修改rsp，即栈顶的位置。

![](https://raw.githubusercontent.com/zrmin/C-Programming-Language/master/images/202201032314258.jpg)

又一例：在本例中，我们在Red Zone的128字节中，存储了32个整数，刚好使用了128字节的空间，因此，Red Zone刚好可以满足我们的需求，所以我们不需要调整rsp的大小，即栈顶的位置不需要进行调整，也即栈内存空间大小的调整时间被节省下来了。

![](https://raw.githubusercontent.com/zrmin/C-Programming-Language/master/images/202201032337784.jpg)

bar()函数是我们的叶子函数，当我们在处理foo()函数的时候，就在foo()函数的栈顶往低地址方向留出了128字节的空间给bar()函数使用，我们可以发现，如果我们在bar()函数中，存储了32个整数（每个整数4个字节）的话，是不需要修改rsp的值的，也就是说，我们为叶子函数留出的Red Zone的空间大小是足够bar()函数使用的，那么就可以节省下来bar()函数栈调整栈内存空间大小的操作的时间，进而提升函数的执行速度。但是如果我们要存储33个整数的话，Red Zone的128字节的空间就不够用了，我们需要额外再分配4个字节的空间来存储第1个整数，这时，在rsp，即栈顶上方为叶子函数又自动分配了128字节的Red Zone，那么现在这128字节的空间就足以存储下第2~第33共计32整数了。



5. <b>栈帧</b>

当一个函数被调用时，操作系统会为其建立一个进程，该进程拥有一块内存空间VAS，即Virtual Address Space——虚拟地址空间。当一个函数被调用时，会在栈内存中保存该函数需要用到的数据，这些数据有返回值、实参、局部变量等，但如果把这些数据看成一个整体，这个整体就代表了一个被调函数的信息，我们这样一个数据块叫做栈帧Stack Frame。

在进程的VAS中，栈是从高地址生长到低地址，当我们需要的栈空间大小不足或者栈空间富余时，我们通过调整rsp的值，即栈顶指针的值来调整栈空间的大小。rbp保存的是一个栈帧的底，也就是一个栈帧开始的地址，rsp保存的是一个栈帧结束的地址。

当发生函数调用时，有一下几件基本的事情要做：

* 将`call`指令的下一条指令的地址压入栈中，也就是返回地址被压入栈中，以便通过ret指令将程序执行流程返回，此时rsp更新
* 发生`callee-saved`，将rsp的旧值，也就是上一个栈帧的起始位置压入栈中，方便在被调函数返回时，找到上一个栈帧的起始位置，也就是调用函数的有用的数据块。此时，rsp的值再次更新。`push rbp`
* 仍然进行`callee-saved`，将rsp的值保存在rbp中，方便使用rbp来处理被调函数的数据（比如实参、局部变量的存储，数据的定位等）。`mov rbp, rsp`
* 减小rsp的值（叶子函数如果所需要存储在栈内存中的数据大小未超过128字节的Red Zone，便不需要这一步），来扩大栈内存，用来为下面进行的被调函数的数据保存开辟空间。`sub rsp ...`
* 被调函数的实参、局部变量、寄存器等的数据处理
* （如果有第三步，本步执行）增加rsp的值来实现销毁栈区的目的，因为这个被调函数的任务已经完成，为了减少不必要的内存浪费，我需要释放掉这块被占用的内存，是上面第三步减少rsp值的逆操作。`add rsp ...`
* 恢复rbp的值，来标识上一个函数的栈帧，也就是用来标识上一个函数的数据块。此时，rsp的值更新。`pop rbp`
* 返回到`call`指令的下一条指令地址处去执行那条指令。此时上面第一步中的返回地址被从栈中弹出，rsp的值再次更新，此时，rsp所指向的地方正式发生调用前的栈帧的顶点处。`ret`

注意：x86中，恢复rsp和rbp的工作，也就是上面倒数第二步和倒数第3步，可以由一条`leave`指令来完成。`leave`指令相当于：

```assembly
mov rsp, rbp ;是建立栈帧时mov rbp, rsp的逆操作
pop rbp ;恢复rbp的值，此时之前push rbp时保存在栈中的值又被弹出到rbp中
```

每一次发生函数调用时，都会像上面那样操作，但是进程的VAS的大小毕竟是有限的，也即是说栈空间的大小是有限的，如果函数a调用函数b，函数b又调用函数c，函数c又调用函数d……如此反复，那么当函数的调用重数太大时，我们的栈空间一定是会被填满的，那时，如果还有新的函数n被调用，VAS将没有空间可以用来建立函数n的栈帧，那时，就会发生`Stack Overflow`的错误。这个错误，有编程经验的人一定是耳熟能详了。

那么如何解决`Stack Overflow`的问题呢？编译器自有方法，见下文。



6. 
